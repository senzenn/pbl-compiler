{"ast":null,"code":"/**\n * Tokenizer (Lexer) - Breaks source code into tokens\n */\n\n// Token types\nconst TokenType = {\n  // Keywords\n  LET: 'LET',\n  CONST: 'CONST',\n  IF: 'IF',\n  ELSE: 'ELSE',\n  // Identifiers and literals\n  IDENTIFIER: 'IDENTIFIER',\n  NUMBER: 'NUMBER',\n  STRING: 'STRING',\n  // Operators\n  PLUS: 'PLUS',\n  // +\n  MINUS: 'MINUS',\n  // -\n  MULTIPLY: 'MULTIPLY',\n  // *\n  DIVIDE: 'DIVIDE',\n  // /\n  ASSIGN: 'ASSIGN',\n  // =\n\n  // Comparison operators\n  EQUAL: 'EQUAL',\n  // ==\n  NOT_EQUAL: 'NOT_EQUAL',\n  // !=\n  GREATER: 'GREATER',\n  // >\n  LESS: 'LESS',\n  // <\n  GREATER_EQUAL: 'GREATER_EQUAL',\n  // >=\n  LESS_EQUAL: 'LESS_EQUAL',\n  // <=\n\n  // Logical operators\n  AND: 'AND',\n  // &&\n  OR: 'OR',\n  // ||\n\n  // Delimiters\n  SEMICOLON: 'SEMICOLON',\n  // ;\n  LEFT_PAREN: 'LEFT_PAREN',\n  // (\n  RIGHT_PAREN: 'RIGHT_PAREN',\n  // )\n  LEFT_BRACE: 'LEFT_BRACE',\n  // {\n  RIGHT_BRACE: 'RIGHT_BRACE',\n  // }\n\n  // End of file\n  EOF: 'EOF'\n};\n\n// Token class\nclass Token {\n  constructor(type, lexeme, literal = null, line = 0) {\n    this.type = type; // Token type\n    this.lexeme = lexeme; // The actual string value from source\n    this.literal = literal; // Processed value (for numbers, strings)\n    this.line = line; // Line number in source\n  }\n  toString() {\n    return `${this.type} ${this.lexeme} ${this.literal}`;\n  }\n}\n\n// Tokenizer class\nclass Tokenizer {\n  constructor(source) {\n    this.source = source;\n    this.tokens = [];\n    this.start = 0;\n    this.current = 0;\n    this.line = 1;\n\n    // Keywords map\n    this.keywords = {\n      'let': TokenType.LET,\n      'const': TokenType.CONST,\n      'if': TokenType.IF,\n      'else': TokenType.ELSE\n    };\n  }\n  tokenize() {\n    while (!this.isAtEnd()) {\n      // Beginning of the next lexeme\n      this.start = this.current;\n      this.scanToken();\n    }\n    this.tokens.push(new Token(TokenType.EOF, \"\", null, this.line));\n    return this.tokens;\n  }\n  scanToken() {\n    const c = this.advance();\n    switch (c) {\n      // Single-character tokens\n      case '(':\n        this.addToken(TokenType.LEFT_PAREN);\n        break;\n      case ')':\n        this.addToken(TokenType.RIGHT_PAREN);\n        break;\n      case '{':\n        this.addToken(TokenType.LEFT_BRACE);\n        break;\n      case '}':\n        this.addToken(TokenType.RIGHT_BRACE);\n        break;\n      case ';':\n        this.addToken(TokenType.SEMICOLON);\n        break;\n\n      // Operators\n      case '+':\n        this.addToken(TokenType.PLUS);\n        break;\n      case '-':\n        this.addToken(TokenType.MINUS);\n        break;\n      case '*':\n        this.addToken(TokenType.MULTIPLY);\n        break;\n      case '/':\n        if (this.match('/')) {\n          // Comment - skip the rest of the line\n          while (this.peek() !== '\\n' && !this.isAtEnd()) {\n            this.advance();\n          }\n        } else {\n          this.addToken(TokenType.DIVIDE);\n        }\n        break;\n\n      // Assignment and comparison operators\n      case '=':\n        this.addToken(this.match('=') ? TokenType.EQUAL : TokenType.ASSIGN);\n        break;\n      case '!':\n        this.addToken(this.match('=') ? TokenType.NOT_EQUAL : TokenType.NOT);\n        break;\n      case '>':\n        this.addToken(this.match('=') ? TokenType.GREATER_EQUAL : TokenType.GREATER);\n        break;\n      case '<':\n        this.addToken(this.match('=') ? TokenType.LESS_EQUAL : TokenType.LESS);\n        break;\n\n      // Logical operators\n      case '&':\n        if (this.match('&')) {\n          this.addToken(TokenType.AND);\n        }\n        break;\n      case '|':\n        if (this.match('|')) {\n          this.addToken(TokenType.OR);\n        }\n        break;\n\n      // Whitespace\n      case ' ':\n      case '\\r':\n      case '\\t':\n        // Ignore whitespace\n        break;\n      case '\\n':\n        this.line++;\n        break;\n\n      // String literals\n      case '\"':\n        this.string();\n        break;\n      default:\n        if (this.isDigit(c)) {\n          this.number();\n        } else if (this.isAlpha(c)) {\n          this.identifier();\n        } else {\n          console.error(`Unexpected character: ${c} at line ${this.line}`);\n        }\n        break;\n    }\n  }\n\n  // Helper methods\n  isAtEnd() {\n    return this.current >= this.source.length;\n  }\n  advance() {\n    return this.source.charAt(this.current++);\n  }\n  peek() {\n    if (this.isAtEnd()) return '\\0';\n    return this.source.charAt(this.current);\n  }\n  peekNext() {\n    if (this.current + 1 >= this.source.length) return '\\0';\n    return this.source.charAt(this.current + 1);\n  }\n  match(expected) {\n    if (this.isAtEnd()) return false;\n    if (this.source.charAt(this.current) !== expected) return false;\n    this.current++;\n    return true;\n  }\n  addToken(type, literal = null) {\n    const text = this.source.substring(this.start, this.current);\n    this.tokens.push(new Token(type, text, literal, this.line));\n  }\n  isDigit(c) {\n    return c >= '0' && c <= '9';\n  }\n  isAlpha(c) {\n    return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c === '_';\n  }\n  isAlphaNumeric(c) {\n    return this.isAlpha(c) || this.isDigit(c);\n  }\n  string() {\n    while (this.peek() !== '\"' && !this.isAtEnd()) {\n      if (this.peek() === '\\n') this.line++;\n      this.advance();\n    }\n    if (this.isAtEnd()) {\n      console.error(`Unterminated string at line ${this.line}`);\n      return;\n    }\n\n    // Consume the closing \"\n    this.advance();\n\n    // Get the string value without quotes\n    const value = this.source.substring(this.start + 1, this.current - 1);\n    this.addToken(TokenType.STRING, value);\n  }\n  number() {\n    while (this.isDigit(this.peek())) this.advance();\n\n    // Look for a decimal point\n    if (this.peek() === '.' && this.isDigit(this.peekNext())) {\n      // Consume the decimal point\n      this.advance();\n      while (this.isDigit(this.peek())) this.advance();\n    }\n    this.addToken(TokenType.NUMBER, parseFloat(this.source.substring(this.start, this.current)));\n  }\n  identifier() {\n    while (this.isAlphaNumeric(this.peek())) this.advance();\n\n    // See if the identifier is a reserved word\n    const text = this.source.substring(this.start, this.current);\n    const type = this.keywords[text] || TokenType.IDENTIFIER;\n    this.addToken(type);\n  }\n}\nexport { Tokenizer, Token, TokenType };","map":{"version":3,"names":["TokenType","LET","CONST","IF","ELSE","IDENTIFIER","NUMBER","STRING","PLUS","MINUS","MULTIPLY","DIVIDE","ASSIGN","EQUAL","NOT_EQUAL","GREATER","LESS","GREATER_EQUAL","LESS_EQUAL","AND","OR","SEMICOLON","LEFT_PAREN","RIGHT_PAREN","LEFT_BRACE","RIGHT_BRACE","EOF","Token","constructor","type","lexeme","literal","line","toString","Tokenizer","source","tokens","start","current","keywords","tokenize","isAtEnd","scanToken","push","c","advance","addToken","match","peek","NOT","string","isDigit","number","isAlpha","identifier","console","error","length","charAt","peekNext","expected","text","substring","isAlphaNumeric","value","parseFloat"],"sources":["/Users/senzenn/Documents/pbl-compiler/src/compiler/tokenizer.js"],"sourcesContent":["/**\n * Tokenizer (Lexer) - Breaks source code into tokens\n */\n\n// Token types\nconst TokenType = {\n  // Keywords\n  LET: 'LET',\n  CONST: 'CONST',\n  IF: 'IF',\n  ELSE: 'ELSE',\n  \n  // Identifiers and literals\n  IDENTIFIER: 'IDENTIFIER',\n  NUMBER: 'NUMBER',\n  STRING: 'STRING',\n  \n  // Operators\n  PLUS: 'PLUS',             // +\n  MINUS: 'MINUS',           // -\n  MULTIPLY: 'MULTIPLY',     // *\n  DIVIDE: 'DIVIDE',         // /\n  ASSIGN: 'ASSIGN',         // =\n  \n  // Comparison operators\n  EQUAL: 'EQUAL',           // ==\n  NOT_EQUAL: 'NOT_EQUAL',   // !=\n  GREATER: 'GREATER',       // >\n  LESS: 'LESS',             // <\n  GREATER_EQUAL: 'GREATER_EQUAL', // >=\n  LESS_EQUAL: 'LESS_EQUAL', // <=\n  \n  // Logical operators\n  AND: 'AND',               // &&\n  OR: 'OR',                 // ||\n  \n  // Delimiters\n  SEMICOLON: 'SEMICOLON',   // ;\n  LEFT_PAREN: 'LEFT_PAREN', // (\n  RIGHT_PAREN: 'RIGHT_PAREN', // )\n  LEFT_BRACE: 'LEFT_BRACE', // {\n  RIGHT_BRACE: 'RIGHT_BRACE', // }\n  \n  // End of file\n  EOF: 'EOF'\n};\n\n// Token class\nclass Token {\n  constructor(type, lexeme, literal = null, line = 0) {\n    this.type = type;       // Token type\n    this.lexeme = lexeme;   // The actual string value from source\n    this.literal = literal; // Processed value (for numbers, strings)\n    this.line = line;       // Line number in source\n  }\n  \n  toString() {\n    return `${this.type} ${this.lexeme} ${this.literal}`;\n  }\n}\n\n// Tokenizer class\nclass Tokenizer {\n  constructor(source) {\n    this.source = source;\n    this.tokens = [];\n    this.start = 0;\n    this.current = 0;\n    this.line = 1;\n    \n    // Keywords map\n    this.keywords = {\n      'let': TokenType.LET,\n      'const': TokenType.CONST,\n      'if': TokenType.IF,\n      'else': TokenType.ELSE,\n    };\n  }\n  \n  tokenize() {\n    while (!this.isAtEnd()) {\n      // Beginning of the next lexeme\n      this.start = this.current;\n      this.scanToken();\n    }\n    \n    this.tokens.push(new Token(TokenType.EOF, \"\", null, this.line));\n    return this.tokens;\n  }\n  \n  scanToken() {\n    const c = this.advance();\n    \n    switch (c) {\n      // Single-character tokens\n      case '(': this.addToken(TokenType.LEFT_PAREN); break;\n      case ')': this.addToken(TokenType.RIGHT_PAREN); break;\n      case '{': this.addToken(TokenType.LEFT_BRACE); break;\n      case '}': this.addToken(TokenType.RIGHT_BRACE); break;\n      case ';': this.addToken(TokenType.SEMICOLON); break;\n      \n      // Operators\n      case '+': this.addToken(TokenType.PLUS); break;\n      case '-': this.addToken(TokenType.MINUS); break;\n      case '*': this.addToken(TokenType.MULTIPLY); break;\n      case '/': \n        if (this.match('/')) {\n          // Comment - skip the rest of the line\n          while (this.peek() !== '\\n' && !this.isAtEnd()) {\n            this.advance();\n          }\n        } else {\n          this.addToken(TokenType.DIVIDE);\n        }\n        break;\n      \n      // Assignment and comparison operators\n      case '=':\n        this.addToken(this.match('=') ? TokenType.EQUAL : TokenType.ASSIGN);\n        break;\n      case '!':\n        this.addToken(this.match('=') ? TokenType.NOT_EQUAL : TokenType.NOT);\n        break;\n      case '>':\n        this.addToken(this.match('=') ? TokenType.GREATER_EQUAL : TokenType.GREATER);\n        break;\n      case '<':\n        this.addToken(this.match('=') ? TokenType.LESS_EQUAL : TokenType.LESS);\n        break;\n      \n      // Logical operators\n      case '&':\n        if (this.match('&')) {\n          this.addToken(TokenType.AND);\n        }\n        break;\n      case '|':\n        if (this.match('|')) {\n          this.addToken(TokenType.OR);\n        }\n        break;\n      \n      // Whitespace\n      case ' ':\n      case '\\r':\n      case '\\t':\n        // Ignore whitespace\n        break;\n      case '\\n':\n        this.line++;\n        break;\n      \n      // String literals\n      case '\"': this.string(); break;\n      \n      default:\n        if (this.isDigit(c)) {\n          this.number();\n        } else if (this.isAlpha(c)) {\n          this.identifier();\n        } else {\n          console.error(`Unexpected character: ${c} at line ${this.line}`);\n        }\n        break;\n    }\n  }\n  \n  // Helper methods\n  isAtEnd() {\n    return this.current >= this.source.length;\n  }\n  \n  advance() {\n    return this.source.charAt(this.current++);\n  }\n  \n  peek() {\n    if (this.isAtEnd()) return '\\0';\n    return this.source.charAt(this.current);\n  }\n  \n  peekNext() {\n    if (this.current + 1 >= this.source.length) return '\\0';\n    return this.source.charAt(this.current + 1);\n  }\n  \n  match(expected) {\n    if (this.isAtEnd()) return false;\n    if (this.source.charAt(this.current) !== expected) return false;\n    \n    this.current++;\n    return true;\n  }\n  \n  addToken(type, literal = null) {\n    const text = this.source.substring(this.start, this.current);\n    this.tokens.push(new Token(type, text, literal, this.line));\n  }\n  \n  isDigit(c) {\n    return c >= '0' && c <= '9';\n  }\n  \n  isAlpha(c) {\n    return (c >= 'a' && c <= 'z') ||\n           (c >= 'A' && c <= 'Z') ||\n           c === '_';\n  }\n  \n  isAlphaNumeric(c) {\n    return this.isAlpha(c) || this.isDigit(c);\n  }\n  \n  string() {\n    while (this.peek() !== '\"' && !this.isAtEnd()) {\n      if (this.peek() === '\\n') this.line++;\n      this.advance();\n    }\n    \n    if (this.isAtEnd()) {\n      console.error(`Unterminated string at line ${this.line}`);\n      return;\n    }\n    \n    // Consume the closing \"\n    this.advance();\n    \n    // Get the string value without quotes\n    const value = this.source.substring(this.start + 1, this.current - 1);\n    this.addToken(TokenType.STRING, value);\n  }\n  \n  number() {\n    while (this.isDigit(this.peek())) this.advance();\n    \n    // Look for a decimal point\n    if (this.peek() === '.' && this.isDigit(this.peekNext())) {\n      // Consume the decimal point\n      this.advance();\n      \n      while (this.isDigit(this.peek())) this.advance();\n    }\n    \n    this.addToken(\n      TokenType.NUMBER,\n      parseFloat(this.source.substring(this.start, this.current))\n    );\n  }\n  \n  identifier() {\n    while (this.isAlphaNumeric(this.peek())) this.advance();\n    \n    // See if the identifier is a reserved word\n    const text = this.source.substring(this.start, this.current);\n    const type = this.keywords[text] || TokenType.IDENTIFIER;\n    \n    this.addToken(type);\n  }\n}\n\nexport { Tokenizer, Token, TokenType }; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}