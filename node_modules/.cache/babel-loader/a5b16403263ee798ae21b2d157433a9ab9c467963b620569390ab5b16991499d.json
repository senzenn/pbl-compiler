{"ast":null,"code":"/**\n * Parser - Converts tokens into an Abstract Syntax Tree (AST)\n * This is a simplified version for the web demo\n */\n\nclass Parser {\n  constructor(tokens) {\n    this.tokens = tokens;\n    this.current = 0;\n  }\n  parse() {\n    try {\n      const statements = [];\n      while (!this.isAtEnd()) {\n        statements.push(this.statement());\n      }\n      return statements;\n    } catch (error) {\n      console.error(\"Parse error:\", error);\n      return [];\n    }\n  }\n  statement() {\n    // This is a simplified parser that creates basic statement objects\n    // A full implementation would create proper AST nodes\n\n    const token = this.advance();\n\n    // Basic structure for demo purposes\n    return {\n      type: 'Statement',\n      token: token,\n      line: token.line\n    };\n  }\n  isAtEnd() {\n    return this.current >= this.tokens.length || this.tokens[this.current].type === 'EOF';\n  }\n  advance() {\n    if (!this.isAtEnd()) this.current++;\n    return this.tokens[this.current - 1];\n  }\n}\nexport { Parser };","map":{"version":3,"names":["Parser","constructor","tokens","current","parse","statements","isAtEnd","push","statement","error","console","token","advance","type","line","length"],"sources":["/Users/senzenn/Documents/pbl-compiler/src/compiler/parser.js"],"sourcesContent":["/**\n * Parser - Converts tokens into an Abstract Syntax Tree (AST)\n * This is a simplified version for the web demo\n */\n\nclass Parser {\n  constructor(tokens) {\n    this.tokens = tokens;\n    this.current = 0;\n  }\n  \n  parse() {\n    try {\n      const statements = [];\n      \n      while (!this.isAtEnd()) {\n        statements.push(this.statement());\n      }\n      \n      return statements;\n    } catch (error) {\n      console.error(\"Parse error:\", error);\n      return [];\n    }\n  }\n  \n  statement() {\n    // This is a simplified parser that creates basic statement objects\n    // A full implementation would create proper AST nodes\n    \n    const token = this.advance();\n    \n    // Basic structure for demo purposes\n    return {\n      type: 'Statement',\n      token: token,\n      line: token.line\n    };\n  }\n  \n  isAtEnd() {\n    return this.current >= this.tokens.length || \n           this.tokens[this.current].type === 'EOF';\n  }\n  \n  advance() {\n    if (!this.isAtEnd()) this.current++;\n    return this.tokens[this.current - 1];\n  }\n}\n\nexport { Parser }; "],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,MAAMA,MAAM,CAAC;EACXC,WAAWA,CAACC,MAAM,EAAE;IAClB,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,OAAO,GAAG,CAAC;EAClB;EAEAC,KAAKA,CAAA,EAAG;IACN,IAAI;MACF,MAAMC,UAAU,GAAG,EAAE;MAErB,OAAO,CAAC,IAAI,CAACC,OAAO,CAAC,CAAC,EAAE;QACtBD,UAAU,CAACE,IAAI,CAAC,IAAI,CAACC,SAAS,CAAC,CAAC,CAAC;MACnC;MAEA,OAAOH,UAAU;IACnB,CAAC,CAAC,OAAOI,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,cAAc,EAAEA,KAAK,CAAC;MACpC,OAAO,EAAE;IACX;EACF;EAEAD,SAASA,CAAA,EAAG;IACV;IACA;;IAEA,MAAMG,KAAK,GAAG,IAAI,CAACC,OAAO,CAAC,CAAC;;IAE5B;IACA,OAAO;MACLC,IAAI,EAAE,WAAW;MACjBF,KAAK,EAAEA,KAAK;MACZG,IAAI,EAAEH,KAAK,CAACG;IACd,CAAC;EACH;EAEAR,OAAOA,CAAA,EAAG;IACR,OAAO,IAAI,CAACH,OAAO,IAAI,IAAI,CAACD,MAAM,CAACa,MAAM,IAClC,IAAI,CAACb,MAAM,CAAC,IAAI,CAACC,OAAO,CAAC,CAACU,IAAI,KAAK,KAAK;EACjD;EAEAD,OAAOA,CAAA,EAAG;IACR,IAAI,CAAC,IAAI,CAACN,OAAO,CAAC,CAAC,EAAE,IAAI,CAACH,OAAO,EAAE;IACnC,OAAO,IAAI,CAACD,MAAM,CAAC,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC;EACtC;AACF;AAEA,SAASH,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}